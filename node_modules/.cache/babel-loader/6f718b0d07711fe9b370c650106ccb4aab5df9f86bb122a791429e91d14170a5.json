{"ast":null,"code":"import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"p-8 text-gray-100 flex flex-col items-center\"\n};\nconst _hoisted_2 = {\n  class: \"mb-4 text-lg\"\n};\nconst _hoisted_3 = {\n  ref: \"canvas\",\n  class: \"rounded-lg\",\n  style: {\n    width: '100%',\n    height: '100%'\n  }\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"section\", _hoisted_1, [_cache[3] || (_cache[3] = _createElementVNode(\"h1\", {\n    class: \"text-4xl font-bold mb-6\"\n  }, \"Snake\", -1 /* CACHED */)), _createElementVNode(\"div\", _hoisted_2, \"Score: \" + _toDisplayString($data.score), 1 /* TEXT */), _createElementVNode(\"div\", {\n    ref: \"gameContainer\",\n    class: \"p-4 rounded-xl shadow-lg flex justify-center items-center\",\n    style: {\n      backgroundColor: '#2E3138',\n      border: '1px solid #444',\n      width: '80vw',\n      maxWidth: '600px',\n      aspectRatio: '1 / 1'\n    },\n    onTouchstart: _cache[0] || (_cache[0] = (...args) => $options.startTouch && $options.startTouch(...args)),\n    onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.moveTouch && $options.moveTouch(...args)),\n    onTouchend: _cache[2] || (_cache[2] = (...args) => $options.endTouch && $options.endTouch(...args))\n  }, [_createElementVNode(\"canvas\", _hoisted_3, null, 512 /* NEED_PATCH */)], 544 /* NEED_HYDRATION, NEED_PATCH */), _cache[4] || (_cache[4] = _createElementVNode(\"p\", {\n    class: \"text-sm mt-4 opacity-70\"\n  }, \"Swipe or use arrow keys to move.\", -1 /* CACHED */))]);\n}","map":{"version":3,"names":["class","ref","style","width","height","_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2","_toDisplayString","$data","score","onTouchstart","_cache","args","$options","startTouch","onTouchmove","moveTouch","onTouchend","endTouch","_hoisted_3"],"sources":["/Users/daltonteasley/Desktop/portfolio-website-3-Dalton-Teasley/src/components/GamePage.vue"],"sourcesContent":["<template>\n  <section class=\"p-8 text-gray-100 flex flex-col items-center\">\n    <h1 class=\"text-4xl font-bold mb-6\">Snake</h1>\n\n    <div class=\"mb-4 text-lg\">Score: {{ score }}</div>\n\n    <div\n      ref=\"gameContainer\"\n      class=\"p-4 rounded-xl shadow-lg flex justify-center items-center\"\n      :style=\"{\n        backgroundColor: '#2E3138',\n        border: '1px solid #444',\n        width: '80vw',\n        maxWidth: '600px',\n        aspectRatio: '1 / 1',\n      }\"\n      @touchstart=\"startTouch\"\n      @touchmove=\"moveTouch\"\n      @touchend=\"endTouch\"\n    >\n      <canvas\n        ref=\"canvas\"\n        class=\"rounded-lg\"\n        :style=\"{ width: '100%', height: '100%' }\"\n      ></canvas>\n    </div>\n\n    <p class=\"text-sm mt-4 opacity-70\">Swipe or use arrow keys to move.</p>\n  </section>\n</template>\n\n<script>\nexport default {\n  name: \"GamePage\",\n\n  data() {\n    return {\n      ctx: null,\n      tileCount: 25,\n      tileSize: 0, // will calculate dynamically\n      snake: [{ x: 12, y: 12 }],\n      direction: { x: 1, y: 0 },\n      food: { x: 5, y: 5 },\n      score: 0,\n      gameInterval: null,\n      speed: 120,\n\n      // touch handling\n      touchStartX: 0,\n      touchStartY: 0,\n      touchEndX: 0,\n      touchEndY: 0,\n      swipeThreshold: 30,\n    };\n  },\n\n  methods: {\n    startGame() {\n      const canvas = this.$refs.canvas;\n      const size = this.$refs.gameContainer.clientWidth;\n\n      canvas.width = size;\n      canvas.height = size;\n\n      this.tileSize = size / this.tileCount;\n      this.ctx = canvas.getContext(\"2d\");\n\n      window.addEventListener(\"keydown\", this.handleKey);\n\n      this.spawnFood();\n      this.gameInterval = setInterval(this.gameLoop, this.speed);\n    },\n\n    handleKey(e) {\n      switch (e.key) {\n        case \"ArrowUp\":\n          if (this.direction.y !== 1) this.direction = { x: 0, y: -1 };\n          break;\n        case \"ArrowDown\":\n          if (this.direction.y !== -1) this.direction = { x: 0, y: 1 };\n          break;\n        case \"ArrowLeft\":\n          if (this.direction.x !== 1) this.direction = { x: -1, y: 0 };\n          break;\n        case \"ArrowRight\":\n          if (this.direction.x !== -1) this.direction = { x: 1, y: 0 };\n          break;\n      }\n    },\n\n    // touch controls\n    startTouch(e) {\n      this.touchStartX = e.changedTouches[0].clientX;\n      this.touchStartY = e.changedTouches[0].clientY;\n    },\n    moveTouch(e) {\n      this.touchEndX = e.changedTouches[0].clientX;\n      this.touchEndY = e.changedTouches[0].clientY;\n    },\n    endTouch() {\n      const dx = this.touchEndX - this.touchStartX;\n      const dy = this.touchEndY - this.touchStartY;\n\n      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > this.swipeThreshold) {\n        // horizontal swipe\n        if (dx > 0 && this.direction.x !== -1) this.direction = { x: 1, y: 0 };\n        else if (dx < 0 && this.direction.x !== 1) this.direction = { x: -1, y: 0 };\n      } else if (Math.abs(dy) > this.swipeThreshold) {\n        // vertical swipe\n        if (dy > 0 && this.direction.y !== -1) this.direction = { x: 0, y: 1 };\n        else if (dy < 0 && this.direction.y !== 1) this.direction = { x: 0, y: -1 };\n      }\n    },\n\n    gameLoop() {\n      const head = {\n        x: this.snake[0].x + this.direction.x,\n        y: this.snake[0].y + this.direction.y,\n      };\n\n      // bounds\n      if (head.x < 0 || head.x >= this.tileCount || head.y < 0 || head.y >= this.tileCount) {\n        this.resetGame();\n        return;\n      }\n\n      // self-hit\n      if (this.snake.some(seg => seg.x === head.x && seg.y === head.y)) {\n        this.resetGame();\n        return;\n      }\n\n      this.snake.unshift(head);\n\n      if (head.x === this.food.x && head.y === this.food.y) {\n        this.score++;\n        this.spawnFood();\n      } else {\n        this.snake.pop();\n      }\n\n      this.draw();\n    },\n\n    spawnFood() {\n      this.food = {\n        x: Math.floor(Math.random() * this.tileCount),\n        y: Math.floor(Math.random() * this.tileCount),\n      };\n    },\n\n    draw() {\n      const ctx = this.ctx;\n\n      ctx.fillStyle = \"#1E1E1E\"; // dark background\n      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n      // snake\n      ctx.fillStyle = \"#AB67A1\"; // accent\n      this.snake.forEach(seg => {\n        ctx.fillRect(\n          seg.x * this.tileSize,\n          seg.y * this.tileSize,\n          this.tileSize - 1,\n          this.tileSize - 1\n        );\n      });\n\n      // food\n      ctx.fillStyle = \"#C985BF\";\n      ctx.fillRect(\n        this.food.x * this.tileSize,\n        this.food.y * this.tileSize,\n        this.tileSize - 1,\n        this.tileSize - 1\n      );\n    },\n\n    resetGame() {\n      this.score = 0;\n      this.snake = [{ x: 12, y: 12 }];\n      this.direction = { x: 1, y: 0 };\n      this.spawnFood();\n    },\n  },\n\n  mounted() {\n    setTimeout(() => this.startGame(), 50);\n    window.addEventListener(\"resize\", () => this.startGame());\n  },\n\n  beforeUnmount() {\n    clearInterval(this.gameInterval);\n    window.removeEventListener(\"keydown\", this.handleKey);\n  },\n};\n</script>\n\n<style scoped>\ncanvas {\n  image-rendering: pixelated;\n  touch-action: none; /* prevents scrolling while swiping */\n}\n</style>\n"],"mappings":";;EACWA,KAAK,EAAC;AAA8C;;EAGtDA,KAAK,EAAC;AAAc;;EAiBrBC,GAAG,EAAC,QAAQ;EACZD,KAAK,EAAC,YAAY;EACjBE,KAAK,EAAE;IAAAC,KAAA;IAAAC,MAAA;EAAA;;;uBAtBdC,mBAAA,CA2BU,WA3BVC,UA2BU,G,0BA1BRC,mBAAA,CAA8C;IAA1CP,KAAK,EAAC;EAAyB,GAAC,OAAK,qBAEzCO,mBAAA,CAAkD,OAAlDC,UAAkD,EAAxB,SAAO,GAAAC,gBAAA,CAAGC,KAAA,CAAAC,KAAK,kBAEzCJ,mBAAA,CAmBM;IAlBJN,GAAG,EAAC,eAAe;IACnBD,KAAK,EAAC,2DAA2D;IAChEE,KAAK,EAAE;;;;;;KAMP;IACAU,YAAU,EAAAC,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAC,UAAA,IAAAD,QAAA,CAAAC,UAAA,IAAAF,IAAA,CAAU;IACtBG,WAAS,EAAAJ,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAG,SAAA,IAAAH,QAAA,CAAAG,SAAA,IAAAJ,IAAA,CAAS;IACpBK,UAAQ,EAAAN,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAEC,QAAA,CAAAK,QAAA,IAAAL,QAAA,CAAAK,QAAA,IAAAN,IAAA,CAAQ;MAEnBP,mBAAA,CAIU,UAJVc,UAIU,8B,mEAGZd,mBAAA,CAAuE;IAApEP,KAAK,EAAC;EAAyB,GAAC,kCAAgC,oB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}